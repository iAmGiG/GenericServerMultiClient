#include <stdio.h>      // Standard input/output definitions
#include <stdlib.h>     // Standard library
#include <string.h>     // Memory manipulation
/* 
use for linux sockets only.
#include <unistd.h>     // POSIX operating system API
#include <sys/types.h>  // Primitive system data types
#include <sys/socket.h> // Internet protocol family
#include <netinet/in.h> // Internet address family 
*/
#include <winsock2.h>
#include <pthread.h>    // POSIX threads

#define PORT 8080
#define BACKLOG 5 // How many pending connections queue will hold

// UTF-8 string reversal function
char *reverse_echo_serve(const char *str)
{
    int len = strlen(str);
    // Allocate space for the reverse string with additoanl space for the null terminator.
    char *reversed_str = malloc(len + 1);

    if (reversed_str == NULL)
    {
        perror("malloc has failed");
        return NULL;
    }

    int index, jdex = 0;
    /*
    We do index = len - 1
    because reverse string will have the extra space for the null terminator
    and don't want to check that against and get a type miss match.

    In UTF-8, any byte that begins with the binary bits 10 (which is 0x80 in hexadecimal)
    is a continuation byte, part of a multi-byte character.
    The mask 0xc0 (binary 11000000) is used to check the top two bits of the byte.
     */
    for (index = len - 1; index >= 0; --i)
    {
        if ((str[index] & 0xc0) != 0x80)
        {
            reversed_str[jdex++] = str[i];
        }
    }
    // Insert the null terminator at the end of the string
    reversed_str = '\0';

    return reversed_str;
}

// Thread function to handle client communication
void *handle_client(void *socket)
{
    int sock = *(int *)socket;
    char buffer[1024] = {0};
    ssize_t valread;

    /* the received client data */
    valread = recv(sock, buffer, sizeof(buffer), 0);
    if (valread < 0)
    {
        perror('recv failed');
        close(sock);
        return NULL;
    }

    char *reversed_str = reverse_echo_serve(buffer);
    if (reversed_str == NULL){
        // if the handling of the reverse has failed, error out.
        close(sock);
        return NULL;
    }

    // Send the reverse string back to the client
    send(sock, reversed_str, strlen(reversed_str), 0);

    free(reversed_str);
    close(sock);
    return NULL;
}

int main()
{
    /*
    fd - file descriptor,
    its a unix/linux refernce,
    as descriptprs are used as a abstraction to access underlying system resources like files,
    sockets and pipes, in this cas e a network communication descriptor.
     */
    int server_fd, new_socket;
    /* Sockets are in the form of ints because of the unix/linux system file desciprots,
    as the int is a index to an array in the kernel where the structs representing the files or socket are stored */
    /* socket address end point, the endpoint address the socket will be bound or connected with, incldues an address family, port number and ip. */
    struct sockaddr_in address;
    /* this is to set options on the socket, passed to set socket opiton funciton, to change the defualt behavior of the socket.*/
    int opt = 1;
    /* size of bytes in the socket address endpoint stucture,
    needed because of different socket functions require the address size as a param to know how much memory to read or write when dealing
    with socket addresses. */
    int addrlen = sizeof(address);
    /* p thread t = the thraed id, we just allocate space in memory for the thread id that will be generated by p thread create fucntion.
    The id is assged by the sytem when the thread iis successfully created, and p thread create will store the id in the space passed in. */
    pthread_t thread_id;

    // Step 1: Creating a TCP socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
    // Optionally set master socket to allow multiple connections
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
    // Step 2: Binding the Socket
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY; // Listen to any IP address
    address.sin_port = htons(PORT);       // Host TO Network Short byte order

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // Step 3: Listening for Incoming Connections
    if (listen(server_fd, BACKLOG) < 0)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("Server is listening on port %d\n", PORT);
    while (1)
    {
        printf("awaiting new connection...\n");
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0)
        {
            /* data */
            perror("accept");
            continue;
        }

        int *new_sock = malloc(sizeof(int));
        *new_sock = new_socket;

        /* handle client is a void pointer because the create function needs to abstractly point to that function to run it on the thread. */
        // Create a new thread for each client
        if (pthread_create(&thread_id, NULL, handle_client, (void *)new_sock) != 0)
        {
            perror("pthread_create failed");
            free(new_sock); // Don't forget to free the allocated memory if thread creation fails
        }
    }

    return 0;
}
